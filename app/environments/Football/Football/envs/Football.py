"""Football_env.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cKf6T-t7YYf22huSlhhf9Uuk3gMurKmZ
"""

import numpy as np
import gym

class Football:  # The class encapsulating the environment
    '''
    Actions [0 : Stand, 1 : Up, 2 : Right, 3 : Down, 4 : Left]
    These are the representing no.s for the mentioned actions
    '''

    def __init__(self, length=8, width=8, goalPositions=[2, 6]):
        
        # The players start at random locations
        pA=[np.random.randint(length), np.random.randint(length)] 
        pB=[np.random.randint(length), np.random.randint(length)]
        
        self.h = length   # Length of the Football Pitch    
        self.w = width    # Width of the Football Pitch
        # PS: We know the ratio of Length: Width is not 1:2, but they have been chosen keeping in mind the computational feasibility. 
        
        self.goalPositions = np.array(goalPositions)   # This means that the middle 4 positions at the right and left are the goals
        
        self.positions = np.array([pA, pB])            # This array stores the positions of the both the players
        
        self.initPositions = np.array([pA, pB])        # This array stores the initial position of both the players
        
        self.ballOwner = np.random.randint(2)          # Randomly, one of the players will be given the ball
        
        self.reward = np.zeros(2,)                              # Initially the reward is 0
        self.current_player_num=self.choosePlayer()
        # We have kept the observation list empty because we don't want to bias the choice of the participant for the State Space.
        #self.observation_space = np.concat((pA)
        self.observation=[]
        self.done = 0                                   # This stores whether the game needs to be restart with new position (in the case of a goal)

    def reset(self):
        self.done = 0
        self.reward = np.zeros(2,)
        
        self.initPositions[0] = [np.random.randint(self.h), np.random.randint(self.h)]
        self.initPositions[1] = [np.random.randint(self.h), np.random.randint(self.h)]
        ballOwner = self.choosePlayer()
        self.current_player_num=self.choosePlayer()
        self.positions = self.initPositions.copy()
        self.ballOwner = ballOwner

    def step(self, action):
        if self.done == 1:
          self.reset()
        self.move(first, action)                   # We chose the first player at random
        if self.done == 1:
          return self.observation, self.reward, self.done
        if not done:
            self.current_player_num = (self.current_player_num + 1) % 2   
        return self.observation,self.reward, self.done

    def move(self, player, action):
        opponent = 1 - player
        
        newPosition = self.positions[player] + self.actionToMove(action)
        #print("new position",newPosition)
        # If it's opponent position
        if (newPosition == self.positions[opponent]).all():
            self.ballOwner = opponent
            self.reward=-10
        # If it's a goal
        elif self.ballOwner is player and self.isInGoal(*newPosition) >= 0:
            self.done = 1
            return 1 - self.isInGoal(*newPosition)
        # If it's in the board
        elif self.isInBoard(*newPosition):
            self.positions[player] = newPosition
        if(self.ballOwner!=0):
          self.reward=-1
        return -1

    def actionToMove(self, action):
        switcher = {
            0: [0, 0],
            1: [0, 1],
            2: [1, 0],
            3: [0, -1],
            4: [-1, 0],
        }
        return switcher.get(action)

    def isInGoal(self, x, y):
        g1, g2 = self.goalPositions
        if (g1 <= y <= g2):
            if x == -1:
                self.done = 1
                self.reward = -20 # if the ball reaches the right goal post, then the rewards shall be -1
                return 1 
            elif x == self.w:
                self.done = 1
                self.reward = 20 # if the ball reaches the right goal post, then the rewards shall be 1
                return 0
        return -1

    def isInBoard(self, x, y):
        return (0 <= x < self.w and 0 <= y < self.h)

    def choosePlayer(self):
        return np.random.randint(0, 2)
    def render(self, positions=None, ballOwner=None):
        positions = self.positions if positions is None else np.array(positions)
        ballOwner = self.ballOwner if ballOwner is None else ballOwner

        board = ''
        for y in range(self.h)[::-1]:
            for x in range(self.w):
                if ([x, y] == positions[0]).all():
                    board += 'A' if ballOwner is 0 else 'a'
                elif ([x, y] == positions[1]).all():
                    board += 'B' if ballOwner is 1 else 'b'
                else:
                    board += '-'
            board += '\n'

        print(board)

class modf_football(Football):
  def __init__(self, length=8, width=8, goalPositions=[2, 6]):
    super().__init__()
    self.observation_space=gym.spaces.Box(0,1,(7,))
    self.n_players=2
    self.reward=np.zeros(2,) 
    self.action_space=gym.spaces.Discrete(1)
    self.name='Football'
    self.current_player_num=0
    self.observation=np.random.rand(7,)
    
  #modifying the step and move function to get the updated reward system
  def step(self, action):
        print('action',action)
        if self.done == 1:
          self.reset()
        player=self.current_player_num
        self.move(player, action)                   # We chose the first player at random
        if self.done == 1:
          return self.observation, self.reward, self.done,{}
        if not self.done:
            self.current_player_num = (self.current_player_num + 1) % 2   
        return self.observation,self.reward, self.done,{}
  
  def move(self, player, action):
        opponent = 1 - player
        
        
        newPosition = self.positions[player] + self.actionToMove(action)
        #print("new position",newPosition)
        # If it's opponent position
        if (newPosition == self.positions[opponent]).all():
            self.ballOwner = opponent
            self.reward[player]=-10
        # If it's a goal
        elif self.ballOwner is player and self.isInGoal(*newPosition) >= 0:
            self.done = 1
            return 1 - self.isInGoal(*newPosition)
        # If it's in the board
        elif self.isInBoard(*newPosition):
            self.positions[player] = newPosition
        if(self.ballOwner!=0):
            self.reward[player]=-1
        self.observation=np.array(([self.ballOwner,*self.positions[player],*self.positions[opponent],(8-self.positions[player][0]),(8-self.positions[player][1])]))
        return -1
  def seed(*x):
      return 0 
  def metadata(x):
      return 0 
  def legal_actions(self):
    return gym.spaces.Discrete(5)
  def close(self):
    pass

  